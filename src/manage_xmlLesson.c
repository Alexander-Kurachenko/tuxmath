/***************************************************************
 *  manage_xmlLesson.c                                          *
 *                                                              *
 *  Description:  Read XML lesson files generated by            *
 *                Tux4kids-Admin and write result files for it. *                                         *
 *  Author:       Vikas Singh 					*
 *                 vikassingh008@gmail.com ,2010 		*
 *  Copyright:    GPL v3 or later                               *
 *  							    	*
 *  						          	*
 *                                                          	*
 *                                                          	*
 *  TuxMath                                                 	*
 *  Part of "Tux4Kids" Project                              	*
 *  http://tux4kids.alioth.debian.org/                      	*
 ***************************************************************/


#include <stdio.h>
#include <libxml/parser.h>
#include <libxml/tree.h>
#include"manage_xmlLesson.h" 
#include"schoolmode.h"
#include"factoroids.h"
#include"fileops.h"
#include"SDL_extras.h"
#include"game.h"
#include"options.h"
#include"mathcards.h"

//Local Function prototypes for reading
int parse_fractions(xmlNode *);
int parse_factors(xmlNode *);
void parse_tuxmath_game(xmlNode *);
//Local Function prototypes for writing
void write_fractions();
void write_factors();
void write_tuxmath_game();
//initialize read and write 
int init_readwrite(char *);
void clean_up();

void parse_options_math(char* , int );

//variables
  xmlDocPtr doc_read,doc_write;

xmlNodePtr root_write = NULL;  /* node pointer for writing */
    xmlDtdPtr dtd = NULL;  //writing
 xmlNode *root_read = NULL; //reading
int total_no_menus,game_score,current_no_of_waves;  
    char buff[256];

  char menu_names[MAX_MENU_ITEMS][MENU_ITEM_LENGTH] = {{'\0'}};

 // struct input_per_wave *input; //defined here
//extern struct result_per_wave *result; //defined in factoroids.c

//char *xml_lesson_path;


int manage_xmlLesson(char *xml_lesson_path)
{
xmlNode *cur_node;
int i;
char fn[PATH_MAX];
char test_file[PATH_MAX]; //this files is used to extract time and date and then deleted
char *write_directory;

//time and date related variables
time_t filetime;
  struct stat filestat;
  struct tm datetime;
  FILE* fp; 


if(init_readwrite(xml_lesson_path)==-1)
return 0;

input_factoroids.wave_input = ( struct input_per_wave *) malloc(MAX_WAVES * sizeof(struct input_per_wave));

  if (input_factoroids.wave_input == NULL)
  {
    printf("Allocation of input to store input values failed");
    return 0;
  }

 for(i=0 , cur_node = root_read->children    ; cur_node != NULL   ;      cur_node = cur_node->next)
  {
    current_game_index=i;
     if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "factors" ) )
     {  
        if(display_screen(i)==-1)    // i highlights the next game to be played
             break;
       i++;   
       current_no_of_waves=parse_factors(cur_node);
       factoroids_schoolmode(0,current_no_of_waves);
       write_factors();  
 
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "fractions" ) )
     {  
        if(display_screen(i)==-1)    // i highlights the next game to be played
             break;
        i++;          
        current_no_of_waves=parse_fractions(cur_node);
       factoroids_schoolmode(1,current_no_of_waves);
       write_fractions();   
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "tuxmath_game" ) )
     {  
        if(display_screen(i)==-1)    // i highlights the next game to be played
             break;
        i++;          
      //start uncluttered game by redifining the option settings to global
      read_global_config_file();
      parse_tuxmath_game(cur_node);
	game();
      write_tuxmath_game();
     }
  

  }
  // --------------------------------------------------------------------------

 #ifdef BUILD_MINGW32
     write_directory = GetDefaultSaveDir(PROGRAM_NAME);
#else
     write_directory = strdup(getenv("HOME"));
#endif

      //Decide the write directory for writing result  
      write_directory= strdup(getenv("HOME"));




/* FIXME there must be a better method way to do than this    */ 
/*Extract date and time by writing a test file to the same directory*/
/* where we are going to write result and extracting date and time from it */
/*and then deleting that file. */
/* We're going to want to write the date.  Use the filetime  */
    /* rather than calling "time" directly, because "time"       */
    /* returns the time according to whatever computer is        */
    /* running tuxmath, and in a server/client mode it's likely  */
    /* that some of the clients' clocks may be wrong. Use      */
    /* instead the time according to the server on which the     */
    /* accounts are stored, which can be extracted from the      */
    /* modification time of the summary we just wrote.           */
	
snprintf(test_file, PATH_MAX, "%s/testfile",write_directory);
fp=fopen(test_file,"w");
if (fp){
fprintf(fp, "\ntest file");
fclose(fp);
} 
else {fprintf(stderr,"test file not written.\n");}
    
//time and date related code
if (stat(test_file,&filestat) == 0) {
      filetime = filestat.st_mtime;
    } else {
      filetime = time(NULL);
    }
localtime_r(&filetime,&datetime); /* generate broken-down time */

remove(test_file); //got date and time so remove the file






//write the result file
	snprintf(fn, PATH_MAX, "%s/result%d-%d-%d__%d:%d:%d.xml",write_directory,datetime.tm_year+1900, 
              datetime.tm_mon+1, datetime.tm_mday,datetime.tm_hour,datetime.tm_min,datetime.tm_sec);

      if( xmlSaveFormatFileEnc(fn, doc_write, "UTF-8", 1)==-1)
          fprintf(stderr,
              "\nError: couldn't write result file: "
              "%s\n",fn);
      else
         printf("\nResult file saved : %s\n",fn);


clean_up();

/*
* this is to debug memory for regression tests
 */
 xmlMemoryDump();
    return(0);

}


int init_readwrite(char *xml_lesson_path)
{

//code related to reading
xmlNode *cur_node;
  char fn[4096];
//char *lesson_path = "schoolmode/lessonData.xml";
 // snprintf(fn, 4096, "%s/images/%s", DATA_PREFIX, lesson_path);

snprintf(fn, 4096, "%s", xml_lesson_path);

int i;
  //xmlChar *Num_asteroids;
//int serial_number;

  // --------------------------------------------------------------------------
  // Open XML document
  // --------------------------------------------------------------------------

  doc_read = xmlParseFile(fn);

  if (doc_read == NULL) 
        printf("error: could not parse file %s \n",xml_lesson_path);
  else 
        printf("parsed file %s\n",xml_lesson_path);
  // --------------------------------------------------------------------------
  // XML root.
  // --------------------------------------------------------------------------

  /*Get the root element node */
  root_read = xmlDocGetRootElement(doc_read);
  
  // --------------------------------------------------------------------------
  // Must have root element, a name and the name must be "lessonData"
  // --------------------------------------------------------------------------
  
  if( !root_read || 
      !root_read->name ||
      xmlStrcmp(root_read->name,(const xmlChar *)"lessonData") ) 
  {
     xmlFreeDoc(doc_read);
     return -1;
  }

  // --------------------------------------------------------------------------
  // lessonData children: For each factors
  // --------------------------------------------------------------------------


  for(  i=0 , cur_node = root_read->children    ;   cur_node != NULL   ;    cur_node = cur_node->next)
  {
     if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "factors" ) )
     {  
            sprintf(menu_names[i], "%s", cur_node->name); 
            i++;
               //menu_names[i]=(char *)cur_node->name;
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "fractions" ) )
     {  
                sprintf(menu_names[i], "%s", cur_node->name); 
                i++;
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "tuxmath_game" ) )
     {  
                sprintf(menu_names[i], "%s", cur_node->name); 
                i++;
     }

  }

total_no_menus=i;

game_completed=(int *)calloc(i,sizeof(i));

//code related to writing

#if !defined(LIBXML_TREE_ENABLED) || !defined(LIBXML_OUTPUT_ENABLED)
fprintf(stderr, "Tree support for writing XML result files not compiled in\n");
    return -1;
#endif
//Macro to check that the libxml version in use is compatible with the version the software has been compiled against
    LIBXML_TEST_VERSION;

    /* 
     * Creates a new document, a node and set it as a root node
     */
    doc_write = xmlNewDoc(BAD_CAST "1.0");
    root_write = xmlNewNode(NULL, BAD_CAST "resultData");
    xmlDocSetRootElement(doc_write, root_write);

    /*
     * Creates a DTD declaration. Isn't mandatory. 
     */
    dtd = xmlCreateIntSubset(doc_write, BAD_CAST "resultData", NULL, BAD_CAST "");
return 0;

}



//parse factors 
int parse_factors(xmlNode *cur_node)
{
 xmlNode *child_node;
char temp_string[1][5]={{'\0'}}; //used in sprintf to convert finally to integer corrresponding to a particular wave no
 xmlChar *wave,*temp;


int i=0;

       //printf("Element: %s \n", cur_node->name); 

        // For each child of factors: i.e. wave
        for(child_node = cur_node->children; child_node != NULL; child_node = child_node->next)
        {
           if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"wave_factors") )
           {
             // serial_number++; 
             // printf("   Child=%s\n", child_node->name);
             // printf("         Serial number=%d\n", serial_number);   
              
            
              wave= xmlNodeGetContent(child_node);
              if(wave)
               {
                 //printf("         Wave: %s\n", wave);
                 sprintf(temp_string[0], "%s", wave); 
                 input_factoroids.wave_input[i++].wave_no=atoi(temp_string[0]); 
                 //waves_parsed[i++]=atoi(wave_string[0]);
               }
              xmlFree(wave);
           }          
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"lives") )
           {         
            
              temp= xmlNodeGetContent(child_node);
              if(temp)
               {
                 //printf("         Wave: %s\n", wave);
                 sprintf(temp_string[0], "%s", wave); 
                 input_factoroids.lives=atoi(temp_string[0]); 
                 //waves_parsed[i++]=atoi(wave_string[0]);
               }
              xmlFree(temp);
           }


         }
return i;
}



//parse fractions
int parse_fractions(xmlNode *cur_node)
{
 xmlNode *child_node;
char temp_string[1][5]={{'\0'}}; //used in sprintf to convert finally to integer corrresponding to a particular wave no
 xmlChar *wave,*temp;
int i=0;


 //printf("Element: %s \n", cur_node->name); 

        // For each child of fractions: i.e. wave
        for(child_node = cur_node->children; child_node != NULL; child_node = child_node->next)
        {
           if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"wave_fractions") )
           {

           //   printf("   Child=%s\n", child_node->name);
            //  printf("         Serial number=%d\n", serial_number);   
              
            
              wave= xmlNodeGetContent(child_node);
             // if(wave) printf("         Wave: %s\n", wave);
              if(wave)
               {
              //   printf("         Wave: %s\n", wave);
                 sprintf(temp_string[0], "%s", wave); 
                 input_factoroids.wave_input[i++].wave_no=atoi(temp_string[0]); 
                 //waves_parsed[i++]=atoi(wave_string[0]);
               } 
              xmlFree(wave);
           }          

         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"lives") )
           {         
            
              temp= xmlNodeGetContent(child_node);
              if(temp)
               {
                 //printf("         Wave: %s\n", wave);
                 sprintf(temp_string[0], "%s", wave); 
                 input_factoroids.lives=atoi(temp_string[0]); 
                 //waves_parsed[i++]=atoi(wave_string[0]);
               }
              xmlFree(temp);
           }
         }
return i;
}


//parse tuxmath_game options for playing tuxmath game
void parse_tuxmath_game(xmlNode *cur_node)
{
 xmlNode *child_node_one,*child_node_two;
 xmlChar *value;
char option_string[1][5]={{'\0'}}; //used in sprintf to convert finally to integer corrresponding to a particular option value

//initial settings 

   MC_SetOpt(TYPING_PRACTICE_ALLOWED, 0);
 MC_SetOpt(ADDITION_ALLOWED, 0);
MC_SetOpt(SUBTRACTION_ALLOWED, 0);
 MC_SetOpt(MULTIPLICATION_ALLOWED, 0);
 MC_SetOpt(DIVISION_ALLOWED, 0);

/*
parse_options_math("addition_allowed",0);
parse_options_math("subtraction_allowed",0);
parse_options_math("multiplication_allowed",0);
parse_options_math("divison_allowed",0);*/
        // For each child of tuxmath_game: 
        for(child_node_one = cur_node->children; child_node_one != NULL; child_node_one = child_node_one->next)
        {
           if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"typing_practice") )
           {
                MC_SetOpt(TYPING_PRACTICE_ALLOWED, 1);

                        for(child_node_two = child_node_one->children; child_node_two != NULL; child_node_two = child_node_two->next)
                             {          
                                        

          			     
                                     if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_num") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_typing_num",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_num") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_typing_num",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

                             }
 
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"addition") )
           {
		 MC_SetOpt(ADDITION_ALLOWED, 1);
                        for(child_node_two = child_node_one->children; child_node_two != NULL; child_node_two = child_node_two->next)
                             {

                                        if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_augend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_augend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_augend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_augend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

                                    else   if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_addend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_addend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_addend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_addend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }
				     
                             }

           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"subtraction") )
           {
                     MC_SetOpt(SUBTRACTION_ALLOWED, 1);

                        for(child_node_two = child_node_one->children; child_node_two != NULL; child_node_two = child_node_two->next)
                             {

  
                                     if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_minuend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_minuend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_minuend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_minuend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

                                    else   if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_subtrahend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_subtrahend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_subtrahend") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_subtrahend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }
				     
                             }

           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"multiplication") )
           {
 	                            MC_SetOpt(MULTIPLICATION_ALLOWED, 1);

                       for(child_node_two = child_node_one->children; child_node_two != NULL; child_node_two = child_node_two->next)
                             {

                                       if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_multiplier") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_multiplier",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_multiplier") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_multiplier",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

                                    else   if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_multiplicand") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_subtrahend",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_multiplicand") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_multiplicand",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }
				     
                             }


           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"divison") )
           {
		 MC_SetOpt(DIVISION_ALLOWED, 1);

                       for(child_node_two = child_node_one->children; child_node_two != NULL; child_node_two = child_node_two->next)
                             {

                                      if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_divisor") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_divisor",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_divisor") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_divisor",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

                                    else   if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"min_quotient") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("min_quotient",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }

          			     else  if ( child_node_one->type == XML_ELEMENT_NODE  &&
                                            !xmlStrcmp(child_node_two->name, (const xmlChar *)"max_quotient") )
                                       {
            
                                            value= xmlNodeGetContent(child_node_two);

                                             if(value)
                                                {
                                                   sprintf(option_string[0], "%s", value); 
			                           parse_options_math("max_quotient",atoi(option_string[0]));
                                                
                                                 } 
                                          xmlFree(value);
                                        }
				     
                             }

           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"repeat_wrongs") )
           {
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
                              parse_options_math("repeat_wrongs",atoi(option_string[0]));
                             } 

                xmlFree(value); 
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"allow_negatives") )
           {
              MC_SetOpt(ALLOW_NEGATIVES, 1);
		/*value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
                              parse_options_math("allow_negatives",atoi(option_string[0]));
                             } 

                xmlFree(value); */
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"format_answer_last") )
           {
              MC_SetOpt(FORMAT_ANSWER_LAST, 1);
              MC_SetOpt(FORMAT_ANSWER_FIRST, 0);
              MC_SetOpt(FORMAT_ANSWER_MIDDLE, 0);
     
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
				parse_options_math("format_add_answer_last",atoi(option_string[0]));
		                parse_options_math("format_sub_answer_last",atoi(option_string[0]));
                		parse_options_math("format_mul_answer_last",atoi(option_string[0]));
                		parse_options_math("format_div_answer_last",atoi(option_string[0]));
                             } 
                
                xmlFree(value);
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"format_answer_first") )
           {
              MC_SetOpt(FORMAT_ANSWER_LAST, 0);
              MC_SetOpt(FORMAT_ANSWER_FIRST, 1);
              MC_SetOpt(FORMAT_ANSWER_MIDDLE, 0);
     
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
				parse_options_math("format_add_answer_first",atoi(option_string[0]));
		                parse_options_math("format_sub_answer_first",atoi(option_string[0]));
                		parse_options_math("format_mul_answer_first",atoi(option_string[0]));
                		parse_options_math("format_div_answer_first",atoi(option_string[0]));
                             } 
                
                xmlFree(value);
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"format_answer_middle") )
           {
              MC_SetOpt(FORMAT_ANSWER_LAST, 0);
              MC_SetOpt(FORMAT_ANSWER_FIRST, 0);
              MC_SetOpt(FORMAT_ANSWER_MIDDLE, 1);
     
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
				parse_options_math("format_add_answer_middle",atoi(option_string[0]));
		                parse_options_math("format_sub_answer_middle",atoi(option_string[0]));
                		parse_options_math("format_mul_answer_middle",atoi(option_string[0]));
                		parse_options_math("format_div_answer_middle",atoi(option_string[0]));
                             } 
                
                xmlFree(value);
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"max_answer") )
           {
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
                              parse_options_math("max_answer",atoi(option_string[0]));
                             } 

                xmlFree(value); 
           }          
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"allow_paused") )
           {
                       value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value); 
                               Opts_SetAllowPause(atoi(option_string[0]));
                             } 
                       xmlFree(value);
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"starting_comets") )
           {
                        value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value); 
                               Opts_SetStartingComets(atoi(option_string[0]));
                             } 
                       xmlFree(value);
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"extra_comets_per_wave") )
           {
                       value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value); 
                               Opts_SetExtraCometsPerWave(atoi(option_string[0]));
                             } 
                       xmlFree(value);
           }          
     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"max_comets") )
           {
                       value= xmlNodeGetContent(child_node_two);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value); 
                               Opts_SetMaxComets(atoi(option_string[0]));
                             } 
                       xmlFree(value);
           }     
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"avg_list_length") )
           {
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
                              parse_options_math("avg_list_length",atoi(option_string[0]));
                             } 

                xmlFree(value); 
           } 
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"min_formula_nums") )
           {
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
                              parse_options_math("min_formula_nums",atoi(option_string[0]));
                             } 

                xmlFree(value); 
           } 
         else if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node_one->name, (const xmlChar *)"max_formula_nums") )
           {
		value= xmlNodeGetContent(child_node_one);
                           if(value)
                             {
                               sprintf(option_string[0], "%s", value);
                              parse_options_math("max_formula_nums",atoi(option_string[0]));
                             } 

                xmlFree(value); 
           } 
         
           


         }

}


void parse_options_math(char* name, int val)
{
  int index = -1;
  
  if ((index = MC_MapTextToIndex(name)) != -1) //is it a math opt?
  {
    MC_SetOpt(index, val);
  }
}


//write factors
void write_factors()
{
int k;
xmlNodePtr node = NULL, node1 = NULL;/* node pointers */

node = xmlNewChild(root_write, NULL, BAD_CAST "factors", NULL);

   for (k = 0; k < current_no_of_waves; k++) 
       { 
            node1 = xmlNewChild(node, NULL, BAD_CAST "wave_factors", NULL);
          
            sprintf(buff, "%d", result_factoroids.wave_result[k].wave_completed);
            xmlNewChild(node1, NULL, BAD_CAST "wave_completed", BAD_CAST buff); 

         if(result_factoroids.wave_result[k].wave_completed)
           {  
            sprintf(buff, "%d", result_factoroids.wave_result[k].wave_no);
            xmlNewChild(node1, NULL, BAD_CAST "wave_no", BAD_CAST buff);
 
            sprintf(buff, "%.2f", ((float)result_factoroids.wave_result[k].wave_time/1000));
            xmlNewChild(node1, NULL, BAD_CAST "wave_time", BAD_CAST buff);
           }
          else
          break;  //do not write the data of waves not played 
        }

   sprintf(buff, "%d", result_factoroids.score);
xmlNewChild(node, NULL, BAD_CAST "score", BAD_CAST buff);


   sprintf(buff, "%d", result_factoroids.lives_remaining);
xmlNewChild(node, NULL, BAD_CAST "lives_remaining", BAD_CAST buff);


}

//write fractions
void write_fractions()
{
int k;
xmlNodePtr node = NULL, node1 = NULL;/* node pointers */

node = xmlNewChild(root_write, NULL, BAD_CAST "fractions", NULL);

   for (k = 0; k < current_no_of_waves; k++) 
       { 
            node1 = xmlNewChild(node, NULL, BAD_CAST "wave_fractions", NULL);
          
            sprintf(buff, "%d", result_factoroids.wave_result[k].wave_completed);
            xmlNewChild(node1, NULL, BAD_CAST "wave_completed", BAD_CAST buff); 

         if(result_factoroids.wave_result[k].wave_completed)
           {  
            sprintf(buff, "%d", result_factoroids.wave_result[k].wave_no);
            xmlNewChild(node1, NULL, BAD_CAST "wave_no", BAD_CAST buff);
 
            sprintf(buff, "%.2f", ((float)result_factoroids.wave_result[k].wave_time/1000));
            xmlNewChild(node1, NULL, BAD_CAST "wave_time", BAD_CAST buff);
           }
          else
          break;  //do not write the data of waves not played 
        }

   sprintf(buff, "%d", result_factoroids.score);
xmlNewChild(node, NULL, BAD_CAST "score", BAD_CAST buff);


   sprintf(buff, "%d", result_factoroids.lives_remaining);
xmlNewChild(node, NULL, BAD_CAST "lives_remaining", BAD_CAST buff);


}



//write result of Tuxmath game in result file
void write_tuxmath_game()
{

int total_answered;
xmlNodePtr node = NULL;/* node pointers */

node = xmlNewChild(root_write, NULL, BAD_CAST "tuxmath_game", NULL);


//Number Of starting questions
    sprintf(buff, "%d", MC_StartingListLength());
    xmlNewChild(node, NULL, BAD_CAST "starting_num_questions", BAD_CAST buff); 


//Number Of Distinct Questions Not Answered Correctly
    sprintf(buff, "%d", MC_WrongListLength());
    xmlNewChild(node, NULL, BAD_CAST "distinct_wrong_num", BAD_CAST buff); 


//Total Number Of Questions attempted
    total_answered = MC_NumAnsweredCorrectly() + MC_NumNotAnsweredCorrectly();
    sprintf(buff, "%d", total_answered);
    xmlNewChild(node, NULL, BAD_CAST "questions_attempted", BAD_CAST buff); 


//Total Number Of Questions attempted correctly
    sprintf(buff, "%d", MC_NumAnsweredCorrectly());
    xmlNewChild(node, NULL, BAD_CAST "questions_correct", BAD_CAST buff); 

//Total Number Of Questions missed
    sprintf(buff, "%d", MC_NumNotAnsweredCorrectly());
    xmlNewChild(node, NULL, BAD_CAST "questions_missed", BAD_CAST buff); 


//Median time/question
    sprintf(buff, "%g", MC_MedianTimePerQuestion());
    xmlNewChild(node, NULL, BAD_CAST "median_time_per_ques", BAD_CAST buff); 

//whether mission accomplished
    (MC_MissionAccomplished())?sprintf(buff, "Yes"):sprintf(buff, "No");
    xmlNewChild(node, NULL, BAD_CAST "mission_accomplished", BAD_CAST buff); 

//Median time/question
    sprintf(buff, "%d",   Opts_LastScore());
    xmlNewChild(node, NULL, BAD_CAST "score", BAD_CAST buff); 


}

void clean_up()
{


int i;
  int frequency,channels,n_timesopened;
  Uint16 format;

  /* Free all images and sounds used by SDL: */
  Cleanup_SDL_Text();

  for (i = 0; i < NUM_IMAGES; i++)
  {
    if (images[i])
      SDL_FreeSurface(images[i]);
    images[i] = NULL;
  }

  for (i = 0; i < NUM_SOUNDS; i++)
  {
    if (sounds[i])
      Mix_FreeChunk(sounds[i]);
    sounds[i] = NULL;
  }

  for (i = 0; i < NUM_MUSICS; i++)
  {
    if (musics[i])
      Mix_FreeMusic(musics[i]);
    musics[i] = NULL;
  }


// Close the audio mixer. We have to do this at least as many times
  // as it was opened.
  n_timesopened = Mix_QuerySpec(&frequency,&format,&channels);
while (n_timesopened) 
{
    Mix_CloseAudio();
    n_timesopened--;
}

free(input_factoroids.wave_input);
free(result_factoroids.wave_result);
 

  SDL_Quit();
/*free the document read*/
  xmlFreeDoc(doc_read);
    /*free the document write*/
    xmlFreeDoc(doc_write);
  /*
   *Free the global variables that may
   *have been allocated by the parser.
   */
  xmlCleanupParser();
//free(xml_lesson_path);


}



