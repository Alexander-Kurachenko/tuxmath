/***************************************************************
 *  manage_xmlLesson.c                                          *
 *                                                              *
 *  Description:  Read XML lesson files generated by            *
 *                Tux4kids-Admin and write result files for it. *                                         *
 *  Author:       Vikas Singh 					*
 *                 vikassingh008@gmail.com ,2010 		*
 *  Copyright:    GPL v3 or later                               *
 *  							    	*
 *  						          	*
 *                                                          	*
 *                                                          	*
 *  TuxMath                                                 	*
 *  Part of "Tux4Kids" Project                              	*
 *  http://tux4kids.alioth.debian.org/                      	*
 ***************************************************************/

#include <stdio.h>
#include <libxml/parser.h>
#include <libxml/tree.h>
#include"manage_xmlLesson.h" 
#include"schoolmode.h"
#include"factoroids.h"
#include"fileops.h"
#include"SDL_extras.h"

//Local Function prototypes for reading
int parse_fractions(xmlNode *);
int parse_factors(xmlNode *);
//Local Function prototypes for writing
void write_fractions();
void write_factors();
//initialize read and write 
int init_readwrite(char *);
void clean_up();
//variables
  xmlDocPtr doc_read,doc_write;

xmlNodePtr root_write = NULL;  /* node pointer for writing */
    xmlDtdPtr dtd = NULL;  //writing
 xmlNode *root_read = NULL; //reading
int total_no_menus,game_score,current_no_of_waves;  
    char buff[256];

  char menu_names[MAX_MENU_ITEMS][MENU_ITEM_LENGTH] = {{'\0'}};
char wave_string[1][5]={{'\0'}}; //used in sprintf to convert finally to integer corrresponding to a particular wave no

//int waves_parsed[MAX_WAVES+1]={-1};

 xmlChar *wave;

  struct input_per_wave *input; //defined here
extern struct result_per_wave *result; //defined in factoroids.c

//char *xml_lesson_path;


int manage_xmlLesson(char *xml_lesson_path)
{
xmlNode *cur_node;
int i;
char fn[PATH_MAX];
char *write_directory;

if(init_readwrite(xml_lesson_path)==-1)
return 0;

input = ( struct input_per_wave *) malloc(MAX_WAVES * sizeof(struct input_per_wave));

  if (input == NULL)
  {
    printf("Allocation of input to store input values failed");
    return 0;
  }

 for(i=0 , cur_node = root_read->children    ; cur_node != NULL   ;      cur_node = cur_node->next)
  {
     if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "factors" ) )
     {  
        if(display_screen(i)==-1)    // i highlights the next game to be played
             break;
       i++;   
       current_no_of_waves=parse_factors(cur_node);
       game_score=factoroids_schoolmode(0,current_no_of_waves);
       write_factors();  
 
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "fractions" ) )
     {  
        if(display_screen(i)==-1)    // i highlights the next game to be played
             break;
        i++;          
        current_no_of_waves=parse_fractions(cur_node);
       game_score=factoroids_schoolmode(1,current_no_of_waves);
       write_fractions();   
     }

  }
  // --------------------------------------------------------------------------

       //snprintf(fn, PATH_MAX, "%s/images/schoolmode/resultData_date_time.xml", DATA_PREFIX );

#ifdef BUILD_MINGW32
     write_directory = GetDefaultSaveDir(PROGRAM_NAME);
#else
     write_directory = strdup(getenv("HOME"));
#endif

      write_directory= strdup(getenv("HOME"));
	snprintf(fn, PATH_MAX, "%s/resultData_date_time.xml",write_directory);


      if( xmlSaveFormatFileEnc(fn, doc_write, "UTF-8", 1)==-1)
          fprintf(stderr,
              "\nError: couldn't write result file: "
              "%s\n",fn);


clean_up();

/*
* this is to debug memory for regression tests
 */
 xmlMemoryDump();
    return(0);

}


int init_readwrite(char *xml_lesson_path)
{

//code related to reading
xmlNode *cur_node;
  char fn[4096];
//char *lesson_path = "schoolmode/lessonData.xml";
 // snprintf(fn, 4096, "%s/images/%s", DATA_PREFIX, lesson_path);

snprintf(fn, 4096, "%s", xml_lesson_path);

int i;
  //xmlChar *Num_asteroids;
//int serial_number;

  // --------------------------------------------------------------------------
  // Open XML document
  // --------------------------------------------------------------------------

  doc_read = xmlParseFile(fn);

  if (doc_read == NULL) 
        printf("error: could not parse file %s \n",xml_lesson_path);
  else 
        printf("parsed file %s\n",xml_lesson_path);
  // --------------------------------------------------------------------------
  // XML root.
  // --------------------------------------------------------------------------

  /*Get the root element node */
  root_read = xmlDocGetRootElement(doc_read);
  
  // --------------------------------------------------------------------------
  // Must have root element, a name and the name must be "lessonData"
  // --------------------------------------------------------------------------
  
  if( !root_read || 
      !root_read->name ||
      xmlStrcmp(root_read->name,(const xmlChar *)"lessonData") ) 
  {
     xmlFreeDoc(doc_read);
     return -1;
  }

  // --------------------------------------------------------------------------
  // lessonData children: For each factors
  // --------------------------------------------------------------------------


  for(  i=0 , cur_node = root_read->children    ;   cur_node != NULL   ;    cur_node = cur_node->next)
  {
     if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "factors" ) )
     {  
            sprintf(menu_names[i], "%s", cur_node->name); 
            i++;
               //menu_names[i]=(char *)cur_node->name;
     }

   else if ( cur_node->type == XML_ELEMENT_NODE  &&
          !xmlStrcmp(cur_node->name, (const xmlChar *) "fractions" ) )
     {  
                sprintf(menu_names[i], "%s", cur_node->name); 
                i++;
     }

  }

total_no_menus=i;



//code related to writing

#if !defined(LIBXML_TREE_ENABLED) || !defined(LIBXML_OUTPUT_ENABLED)
fprintf(stderr, "Tree support for writing XML result files not compiled in\n");
    return -1;
#endif
//Macro to check that the libxml version in use is compatible with the version the software has been compiled against
    LIBXML_TEST_VERSION;

    /* 
     * Creates a new document, a node and set it as a root node
     */
    doc_write = xmlNewDoc(BAD_CAST "1.0");
    root_write = xmlNewNode(NULL, BAD_CAST "resultData");
    xmlDocSetRootElement(doc_write, root_write);

    /*
     * Creates a DTD declaration. Isn't mandatory. 
     */
    dtd = xmlCreateIntSubset(doc_write, BAD_CAST "resultData", NULL, BAD_CAST "");
return 0;

}



//parse factors 
int parse_factors(xmlNode *cur_node)
{
 xmlNode *child_node;
int i=0,serial_number=0;

       //printf("Element: %s \n", cur_node->name); 

        // For each child of factors: i.e. wave
        for(child_node = cur_node->children; child_node != NULL; child_node = child_node->next)
        {
           if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"wave_factors") )
           {
              serial_number++; 
             // printf("   Child=%s\n", child_node->name);
             // printf("         Serial number=%d\n", serial_number);   
              
            
              wave= xmlNodeGetContent(child_node);
              if(wave)
               {
                 //printf("         Wave: %s\n", wave);
                 sprintf(wave_string[0], "%s", wave); 
                 input[i++].wave_no=atoi(wave_string[0]); 
                 //waves_parsed[i++]=atoi(wave_string[0]);
               }
              xmlFree(wave);
           }          
         }
return i;
}



//parse fractions
int parse_fractions(xmlNode *cur_node)
{
 xmlNode *child_node;
int i=0;


 //printf("Element: %s \n", cur_node->name); 

        // For each child of fractions: i.e. wave
        for(child_node = cur_node->children; child_node != NULL; child_node = child_node->next)
        {
           if ( cur_node->type == XML_ELEMENT_NODE  &&
                !xmlStrcmp(child_node->name, (const xmlChar *)"wave_fractions") )
           {

           //   printf("   Child=%s\n", child_node->name);
            //  printf("         Serial number=%d\n", serial_number);   
              
            
              wave= xmlNodeGetContent(child_node);
             // if(wave) printf("         Wave: %s\n", wave);
              if(wave)
               {
              //   printf("         Wave: %s\n", wave);
                 sprintf(wave_string[0], "%s", wave); 
                 input[i++].wave_no=atoi(wave_string[0]); 
                 //waves_parsed[i++]=atoi(wave_string[0]);
               } 
              xmlFree(wave);
           }          
         }
return i;
}




//write factors
void write_factors()
{
int k;
xmlNodePtr node = NULL, node1 = NULL;/* node pointers */

node = xmlNewChild(root_write, NULL, BAD_CAST "factors", NULL);

   for (k = 0; k < current_no_of_waves; k++) 
       { 
            node1 = xmlNewChild(node, NULL, BAD_CAST "wave_factors", NULL);
          
            sprintf(buff, "%d", result[k].wave_completed);
            xmlNewChild(node1, NULL, BAD_CAST "wave_completed", BAD_CAST buff); 

         if(result[k].wave_completed)
           {  
            sprintf(buff, "%d", result[k].wave_no);
            xmlNewChild(node1, NULL, BAD_CAST "wave_no", BAD_CAST buff);
 
            sprintf(buff, "%.2f", ((float)result[k].wave_time/1000));
            xmlNewChild(node1, NULL, BAD_CAST "wave_time", BAD_CAST buff);
           }
          else
          break;  //do not write the data of waves not played 
        }

   sprintf(buff, "%d", game_score);
xmlNewChild(node, NULL, BAD_CAST "score", BAD_CAST buff);


}

//write fractions
void write_fractions()
{
int k;
xmlNodePtr node = NULL, node1 = NULL;/* node pointers */

node = xmlNewChild(root_write, NULL, BAD_CAST "fractions", NULL);

   for (k = 0; k < current_no_of_waves; k++) 
       { 
            node1 = xmlNewChild(node, NULL, BAD_CAST "wave_fractions", NULL);
          
            sprintf(buff, "%d", result[k].wave_completed);
            xmlNewChild(node1, NULL, BAD_CAST "wave_completed", BAD_CAST buff); 

         if(result[k].wave_completed)
           {  
            sprintf(buff, "%d", result[k].wave_no);
            xmlNewChild(node1, NULL, BAD_CAST "wave_no", BAD_CAST buff);
 
            sprintf(buff, "%.2f", ((float)result[k].wave_time/1000));
            xmlNewChild(node1, NULL, BAD_CAST "wave_time", BAD_CAST buff);
           }
          else
          break;  //do not write the data of waves not played 
        }

   sprintf(buff, "%d", game_score);
xmlNewChild(node, NULL, BAD_CAST "score", BAD_CAST buff);


}


void clean_up()
{


int i;
  int frequency,channels,n_timesopened;
  Uint16 format;

  /* Free all images and sounds used by SDL: */
  Cleanup_SDL_Text();

  for (i = 0; i < NUM_IMAGES; i++)
  {
    if (images[i])
      SDL_FreeSurface(images[i]);
    images[i] = NULL;
  }

  for (i = 0; i < NUM_SOUNDS; i++)
  {
    if (sounds[i])
      Mix_FreeChunk(sounds[i]);
    sounds[i] = NULL;
  }

  for (i = 0; i < NUM_MUSICS; i++)
  {
    if (musics[i])
      Mix_FreeMusic(musics[i]);
    musics[i] = NULL;
  }

// Close the audio mixer. We have to do this at least as many times
  // as it was opened.
  n_timesopened = Mix_QuerySpec(&frequency,&format,&channels);
while (n_timesopened) 
{
    Mix_CloseAudio();
    n_timesopened--;
}

free(input);
free(result);
 

  SDL_Quit();
/*free the document read*/
  xmlFreeDoc(doc_read);
    /*free the document write*/
    xmlFreeDoc(doc_write);
  /*
   *Free the global variables that may
   *have been allocated by the parser.
   */
  xmlCleanupParser();
//free(xml_lesson_path);


}



